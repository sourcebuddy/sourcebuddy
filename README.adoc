
= SourceBuddy






SourceBuddy is a very simple Java source compiler facade in front of the JDK-provided `javac` compiler.
It was designed for applications creating Java source code on the fly during run-time.
The JDK API is complex and hard to use.
You have to implement a `JavaFileManager` and `JavaFileObject`, which is possible, but SourceBuddy does it for you.

Using SourceBuddy, you do not need to implement anything except your application logic.
You get a `Compiler` object calling the `Compiler.java()`, and from there, all you need is

* specify the source code either as Java strings or files,
* call `compile()`
* fetch the compiled `.class` files or the loaded classes.

The library provides a one-call API if your application generates only one Java file.
You can call the `Compiler.compile(className,sourceCode)` static method that does everything.
It compiles the source code, loads the class(es) generated from the source, and returns the class.

The following example shows how to use the one-call API:

[source,java]
----
 1. String source = "package com.sb.demo;\n" +
 2.         "\n" +
 3.         "public class MyClass implements TestInterface{\n" +
 4.         "    public String a() {\n" +
 5.         "        return \"x\";\n" +
 6.         "  }\n" +
 7.         "}";
 8. Class<?> myClassClass = Compiler.compile("com.sb.demo.MyClass", source);
 9. TestInterface myClass = (TestInterface)myClassClass.getConstructor().newInstance();
10. String s = myClass.a();

----

The to-be-compiled code is defined in the string variable `source`.
The compilation and loading of the class happen on line 8.
It is the line using the compilation API.
The `MyClass` implemented interface, `TestInterface`, is defined in the project's test.
Classes and interfaces in the host application executing the compilation are available for the Java code to be compiled.
The instance created using reflection can be cast to the implemented interface (line 9), and the method defined there is invoked in line 10.

In this document, we will explain the details of how to use the library, including

* dependency parameters,

* simple API,

* Fluent API,

* support.

== Dependency Parameters


To use the library, it has to be on the classpath for your application, as it is for every library.
The library is available from Maven central.
The Maven central coordinates are:

[source,xml]
----
<dependency>
    <groupId>com.sourcebuddy</groupId>
    <artifactId>SourceBuddy</artifactId>
    <version>1.0.0-SNAPSHOT</version>
</dependency>
----

== Simple APi

You can use the simple API in projects that need to compile only one source file in a compilation unit.
To do that, the class `com.javax0.sourcebuddy.Compiler` defines a static method `compile`.

[soure,java]
----
Class<?> myClassClass = Compiler.compile("com.sb.demo.MyClass", source);

----

The method's first parameter is the binary name of the class to be compiled.
The second parameter is the string source code of the class.

[NOTE]
====
The binary name of a class is the name returned by the method `Class.getName()`.
A class can have three different names:

* Simple name,

* Canonical name, and

* Binary name, many times referred to as name.

The simple name is the name of the class without any package prefix or enclosing class prefix.
The canonical name is the name we usually refer to the classes in the Java source when the class is not imported; hence, the full name is to be used.
The binary name is the name of how the JVM knows the class.
With some simplification, the binary name of the class has the `$` in it for anonymous and inner classes.
Canonical names have `.` between the name of the outer class and the inner classes' names.
Anonymous classes have no canonical name.
In other cases, the binary and canonical names are the same.
====

The method's return value is the class compiled and loaded into the JVM.

If there is an error during the compilation, the call will throw a `CompileException` with the error message in the exception message.

== Fluent API

The fluent API is available when there are more files to be compiled or when you want to do something other than loading with the class files.

The fluent API is chained, offering the possible methods only at the locations where you can use them.
To demonstrate the use of the API, we will use the sample code:

[source,java]
----
 1. String sourceFirstClass = "package com.sb.demo;\n" +
 2.         "\n" +
 3.         "public class FirstClass {\n" +
 4.         "    public String a() {\n" +
 5.         "        return \"x\";\n" +
 6.         "  }\n" +
 7.         "}";
 8. final var compiled = Compiler.java()
 9.         .from("com.sb.demo.FirstClass", sourceFirstClass)
10.         .from(Paths.get("src/test/java"))
11.         .compile();
12. compiled.saveTo(Paths.get("./target/generated_classes"));
13. compiled.stream().forEach(bc -> System.out.println(Compiler.getBinaryName(bc)));
14. final var loaded = compiled.load();
15. Class<?> firstClassClass = loaded.get("com.sb.demo.FirstClass");
16. loaded.stream().forEach( klass -> System.out.println(klass.getSimpleName()));
17. final var compiler = loaded.reset();
18. final var sameCompiler = compiled.reset();

----



=== 1.  Get the compiler object

To start the compilation, you must have a `Compiler` object.
To get that, you have to call the

[source,java]
----
        final var compiled = Compiler.java()

----

=== 2.  Add sources

The next step is to add the source files to the compiler object.
To do that, you can specify the sources one by one as strings, or you can add directories where the source files are.
The overloaded method `from()` is used for both operations.

To add sources individually, you can call

[source,java]
----
                .from("com.sb.demo.FirstClass", sourceFirstClass)

----

The first argument is the binary name of the class.
The second is the actual source code.
To add multiple sources, you can call this method one after the other as many times as you wish.
However, if the sources are in the file system in a directory, you can also call

[source,java]
----
                .from(Paths.get("src/test/java"))

----

In this call, you specify only one parameter, a path pointing to the source root.
It is the directory where the directory structure matching the Java package structure starts.
You can have many calls to this method if you have multiple source trees on the disk.
You can also add some of the sources as strings, individually and others scanned from the file system.

=== 3.  Compile

After the program loaded the sources, the next thing is to compile:

[source,java]
----
                .compile();

----

The result of the compilation is that the bytes codes for the Java source files are generated.
They are not loaded as Java classes into the memory yet.

=== 4.  Save the byte codes

The next step you can do is save the byte codes.
It is not a must.
You can ignore this step if you do not need the compiled byte codes in the file system.

[source,java]
----
        compiled.saveTo(Paths.get("./target/generated_classes"));

----

The argument to this method is the path to where the program will save the class files.
If the directory does not exist, it will be created recursively.
It will create all the subdirectories corresponding to the package structure.
Adding this directory to a standard URL class loader will be able to load these files from the disk.

The return value of this method is `void`, not chainable.
This method is usually the last action you invoke on a compiler.

=== 5.  Stream through the byte codes

Sometimes you do not want to save the byte code to `.class` files.
You can use the compiler object at this stage to iterate through the compiled codes, calling

[source,java]
----
        compiled.stream().forEach(bc -> System.out.println(Compiler.getBinaryName(bc)));

----

The return value of the method `stream()` at this point is `Stream<byte[]>`.
It is up to you how you use these byte arrays.

Many times you may also need the binary name of the class.
You can call the static method `getBinaryName()` to get the name.
It is a utility method that gauges the name of the class from the binary representation.
You can use this method for any byte code, not only those compiled with the compiler.

NOTE: The `getBinaryName()` implementation supports JVM byte code up to 63, which is Java 19.

The API built into the Java run-time is complex because it is designed to handle several input files (Java source code) and output files (generated byte code) reading and writing possibilities. It needs the implementation of complex classes that provide the source code and store the generated byte code.

To ease the burden, this library implements these classes along with a class loader to handle the simple case when you want to compile Java source available during run-time in String objects and you want to load the compiled classes instead of generating `.class` files.

=== 6.  Load the classes

Applications want not only to compile the Java classes on the fly but also to load them.
The aptly named method `load()` can be used to do that.

The method `load()` has two versions.
One is without argument; the other needs a class loader.
The more straightforward and recommended way is:

[source,java]
----
        final var loaded = compiled.load();

----

It will load the classes from the memory-stored byte code to the JVM.
This loading will convert the byte codes to `Class` objects.

There is a version `loadHidden()` that will use a special class loader loading the class as a hidden class.
Hidden classes are defined in link:https://openjdk.org/jeps/371[JEP371].
They are classes dynamically loaded by the program, but they are hidden in the sense that they do not have name.
The only way to access them is via reflection using the class object returned by the library (see the next chapter).
Hidden classes have a technical name, hence you will getsome value if you call `getName()` or `getSimpleName()` on the class.
On the other hand `getCanonicalName()` will return `null`.
`getCanonicalName()` returns the format of the name used in the Java source code to refer to the class.

NOTE: You can load many different hidden classes bearing the same name in the source code.
The Java run-time will delete the name.
SourceBuddy can also be used to load several versions of a single named class, but you must use different compiler objects.
The reason: the `Compiler` object identifies the classes using the names you provided for the compilation.
If there were two classes having the same name, then `loaded.get(className)` would not know which version it has to return.

NOTE: The hidden class loading can also have `ClassOption` vararg arguments.
These control wether a loaded hidden class becomes attached to the classloader and to be the member of a nest host.
To accomodate the possibility the method `loadHidden(ClassOption... options)` also accepts these as vararg parameters.

Note that the methods `load()`, and `loadHidden()` return objects which handle the loaded classes.
These are not the compiler object.

=== 7.  Get access to the classes

When the classes are loaded, your code will want to access some of them.
Since these classes are created during run-time, they are not available during the compile time of your program.
You can access the class objects from the compilers.
After that, you can use casting to an interface the class implements, to a superclass, or you can use standard reflection API.

To get a class object by its name, you can call

[source,java]
----
        Class<?> firstClassClass = loaded.get("com.sb.demo.FirstClass");

----

The class also contains a complimentary method, called `newInstance(String className, Class type)`.
When you call

[source,java]
----
        Object f = loaded.newInstance("com.sb.demo.FirstClass",Object.class);"
----

you will get a new instance of the class.
The second argument can be `Object.class` or any class of interface the dynamically compiled class extends or implements and the object can be cast to this type.
This method is generic, the return type will be the given type, there is no need for casting.


=== 8.  Stream through the class objects

You can also get a stream of the classes.

[source,java]
----
        loaded.stream().forEach( klass -> System.out.println(klass.getSimpleName()));

----

Since the method `load()` returned a new object, this time the method `stream()` is different.
It returns a `Stream<Class>` type and not the byte codes.

=== 9.  Reset the compiler

Last but not least, you can reset the compiler.
You may need to reset the compiler to reuse it to compile additional sources.
In most cases, it is better to get a new compiler calling

[source,java]
----
        final var compiled = Compiler.java()

----

The only case when the reuse of the compiler is needed is when the classes in the new compilation etap need access to the classes in the previous etap.
Using two different compiler objects will compile classes that see the classes of the 'host' code and the classes added to the compiler, but not each other.
When a compiler object is reset, the subsequent compilation round will see all the host classes and all the classes compiled previously and added in the current etap.

When the compilation starts, the compiler will compile all the java classes you ever added to the compilation.
It means that older classes will be recompiled, consuming CPU.
It is the reason why it is not recommended to reset the compiler object, except when it is needed.

To reset the compiler, you can invoke the method

[source,java]
----
        final var compiler = loaded.reset();

----

You can invoke this method on the compiler object, even if you used it to create a loaded object:

[source,java]
----
        final var sameCompiler = compiled.reset();

----

The object you get back from both of these calls is the same as the one you can call

[source,java]
----
        final var compiled = Compiler.java()

----

except that it already contains the classes you added to it previously.

WARNING: You can not redefine a class the program has already compiled.
The program will compile the new source file for an existing class name.
It will store the byte code; you will get the new version when calling `stream()`; you can save the new version.
It will not load into memory when you call `load()`.
The class loader will see that a class under its management is already loaded and skip the loading.
This is a limitation of the Java class loading architecture.
A class loader cannot unload and reload a class.

You cannot reset a compiler, which was used to load hidden classes.
Hidden classes have no names.
The newly defined classes cannot reference them.
Using a reset compiler object in this case would just increase the CPU load without any added benefit.

== Support

The project is open-source; non-commercial; the license is Apache v2.0.

I cannot write that the project is actively developed and supported because this sentence will remain on the internet long after I die.
Have faith; if you have a question or suggestion, create a ticket on GitHub in the project repo.
I am a nice guy, I answer all questions, and my motto from the time I was teaching at TU Budapest is that there is no stupid question, only stupid answer.
I realized later that this motto was firing back during the exams, so I did not use it later.
Here, however, there are no exams.
