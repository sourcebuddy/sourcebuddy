//snipline clPackage filter=package\s(.+);
package com.javax0.sourcebuddy;

import java.lang.invoke.MethodHandles;
import java.net.URL;
import java.net.URLClassLoader;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.Supplier;

/**
 * Class loader that loads a class from a byte array. This loader loads
 * classes passed to the constructor in a map in their compiled binary
 * form. The main use of this class loader is to load the class or classes that
 * were generated during the compilation of a single Java source class that may
 * contain inner classes, anonymous classes and thus need the load of more than
 * one class to have the {@code Class} object usable in your Java code.
 */
public class ByteClassLoader extends URLClassLoader {

    /**
     * Contains the data for a class that was the result of the compilation.
     */
    private static class ClassRecord {
        /**
         * The compiled byte code of the class
         */
        final byte[] code;
        /**
         * The class when the class was already loaded into the JVM.
         */
        Class<?> loadedClass;
        /**
         * {@code true} if the class is to be loaded hidden.
         */
        boolean isHidden;
        /**
         * The class options to use for hidden classes.
         */
        MethodHandles.Lookup.ClassOption[] classOptions;
        /**
         * The lookup object to use to load the class. If this is {@code null} and the class is not hidden then it
         * will be loaded by the current class loader the normal way.
         */
        MethodHandles.Lookup lookup;

        /**
         * Create a new record using the byte code and setting the other parameters the default.
         * @param code is the byte code, must not be {@code null}
         */
        ClassRecord(final byte[] code) {
            this.code = Objects.requireNonNull(code);
        }
    }

    /**
     * All the class records. The key is the canonical name of the class.
     */
    protected final Map<String, ClassRecord> classRecords;

    /**
     * The loading options active for this class loader. See {@link com.javax0.sourcebuddy.Compiler.LoaderOption}
     */
    private final Set<Compiler.LoaderOption> options;

    /**
     * @param parent     passed to the super constructor. For more information see
     *                   {@link URLClassLoader#URLClassLoader(URL[], ClassLoader)}.
     * @param classesMap a map that contains the binary code of the classes that may be
     *                   loaded by this class loader. The key of the map is the name of
     *                   the class that is used when the class is loaded calling the
     *                   method {@link #findClass(String)}. The value in a map element
     *                   is the byte array of the class as generated by the compiler.
     * @param sources    is the list of the source objects that were given to the compiler
     * @param options    contain the loading options, like {@link com.javax0.sourcebuddy.Compiler.LoaderOption#REVERSE}
     */
    ByteClassLoader(ClassLoader parent, final Map<String, byte[]> classesMap, List<StringJavaSource> sources, Compiler.LoaderOption[] options) {
        super(new URL[0], parent);
        this.options = Set.of(options);
        this.classRecords = new HashMap<>();
        addByteCodes(classesMap, sources);
    }

    public void addByteCodes(final Map<String, byte[]> classesMap, List<StringJavaSource> sources) {
        final var map = new HashMap<String, ClassRecord>();
        for (final var e : classesMap.entrySet()) {
            map.put(e.getKey(), new ClassRecord(e.getValue()));
        }

        for (final var source : sources) {
            final var byteCode = map.get(source.binaryName);
            byteCode.isHidden = source.isHidden;
            byteCode.classOptions = source.classOptions;
            byteCode.lookup = source.lookup;
            if (source.isNest) {
                final var lookup = LookupFetcher.nestLookup(source);
                final var namePrefix = source.binaryName + "$";
                for (final var e : map.entrySet()) {
                    if (e.getKey().startsWith(namePrefix)) {
                        e.getValue().isHidden = true;
                        e.getValue().lookup = lookup;
                        e.getValue().classOptions = source.classOptions;
                    }
                }
                map.remove(source.binaryName);
            }
        }
        this.classRecords.putAll(map);
    }

    private static final Map<String, MethodHandles.Lookup> lookups = new ConcurrentHashMap<>();

    @Override
    public Class<?> loadClass(String name) throws ClassNotFoundException {
        final var record = classRecords.get(name);
        if (record != null && (options.contains(Compiler.LoaderOption.REVERSE) || record.isHidden)) {
            return findClass(name);
        } else {
            return super.loadClass(name);
        }
    }

    @Override
    public Class<?> findClass(String name) throws ClassNotFoundException {
        if (classRecords.containsKey(name)) {
            return loadClassFromThisClassLoader(name);
        } else {
            return super.findClass(name);
        }
    }

    private Class<?> loadClassFromThisClassLoader(final String name) throws ClassNotFoundException {
        final var record = classRecords.get(name);
        if (record.loadedClass != null) {
            return record.loadedClass;
        }
        adjustLookupObject(record);
        try {
            if (record.isHidden) {
                loadClassHidden(record);
            } else {
                loadClassNamed(record);
            }
            return record.loadedClass;
        } catch (IllegalAccessException e) {
            throw new ClassNotFoundException("Class '%s' cannot be found".formatted(name));
        }
    }

    /**
     * Load a named class. If there is a lookup object to load the class then it will be loaded using the lookup,
     * otherwise it will be loaded as a normal class by this classloader.
     *
     * @param record the class record
     * @throws IllegalAccessException if the class cannot be loaded
     */
    private void loadClassNamed(final ClassRecord record) throws IllegalAccessException {
        if (record.lookup != null) {
            record.loadedClass = record.lookup.defineClass(record.code);
        } else {
            record.loadedClass = defineClass(Compiler.getBinaryName(record.code), record.code, 0, record.code.length);
        }
    }

    private static void loadClassHidden(final ClassRecord record) throws IllegalAccessException {
        record.loadedClass = record.lookup.defineHiddenClass(record.code, true, record.classOptions)
                .lookupClass();
    }

    /**
     * If there is no lookup object and the class is to be loaded hidden then create a lookup object
     *
     * @param record the class record
     * @throws ClassNotFoundException if the lookup object cannot be created
     */
    private void adjustLookupObject(final ClassRecord record) throws ClassNotFoundException {
        if (record.lookup == null && record.isHidden) {
            record.lookup = getLookup(Compiler.getBinaryName(record.code));
        }
    }

    private record PackageNameLine(String line, String name) {
    }

    private MethodHandles.Lookup getLookup(final String className) throws ClassNotFoundException {
        final PackageNameLine p = getPackageNameLine(className);
        if (lookups.containsKey(p.name)) {
            return lookups.get(p.name);
        } else {
            return createNewLookup(p);
        }
    }

    /**
     * Get the name of the package name, and the package line.
     * <p>
     * The package name is the package part from the name.
     * <p>
     * The package line is the keyword 'package', the name of the package and the line ending ';'.
     *
     * @param className the full name of the class
     * @return the package name and line record
     */
    private static PackageNameLine getPackageNameLine(final String className) {
        int lastDot = className.lastIndexOf('.');
        if (lastDot == -1) {
            return new PackageNameLine("", "");
        } else {
            final var n = className.substring(0, lastDot);
            return new PackageNameLine("package %s;".formatted(n), n);
        }
    }

    private MethodHandles.Lookup createNewLookup(final PackageNameLine p) throws ClassNotFoundException {
        final var packageDot = p.name.length() == 0 ? "" : p.name + ".";
        final var name = ("_" + UUID.randomUUID()).replaceAll("-", "");
        final var canonicalName = packageDot + name;
        try {
            // snippet lookup_creation
            final byte[] lcByteCode = Compiler.java().from(packageDot + name, """
                    %s
                       
                    import java.util.function.Supplier;
                    import java.lang.invoke.MethodHandles;
                                                
                    public class %s implements Supplier<MethodHandles.Lookup> {
                        public %s(){}
                        @Override
                        public MethodHandles.Lookup get() {
                            return MethodHandles.lookup();
                        }
                    }
                    """.formatted(p.line, name, name)).compile().get();
            final var supplier = defineClass(canonicalName, lcByteCode, 0, lcByteCode.length);
            final var lookup = (MethodHandles.Lookup) ((Supplier<?>) supplier.getConstructor().newInstance()).get();
            // end snippet
                /*this goes into the documentation, update if the code above changes
                // snippet lookup_creation_describe
In the code above the variable `p.line` contains the keyword `package`, the name of the package and a `;` semicolon at the end.
When the generated class is in the default package this variable is empty.

`name` is the simple name, `canonicalName` is the canonical name of the class.
The class name is a random unique string (random uuid).
                // end snippet
                 */
            synchronized (lookups) {
                if (!lookups.containsKey(p.name)) {
                    lookups.put(p.name, lookup);
                }
            }
            return lookup;
        } catch (Exception e) {
            throw new ClassNotFoundException("%s cannot be loaded".formatted(name), e);
        }
    }


    /**
     * The class loader remains in memory so long as long the loaded class
     * remains in memory but the source byte array that was used to load the
     * code of the class is not needed anymore. This method removes the element
     * from the map that contained the byte array so that the gc can reclaim the
     * memory.
     *
     * @param name is the name of the class that was recently loaded. The map
     *             should contain an element with this key.
     */
    private void releaseClassByteArray(String name) {
        classRecords.remove(name);
    }

}
